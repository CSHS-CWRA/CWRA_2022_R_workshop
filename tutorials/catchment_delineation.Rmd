---
title: 'Using R and WhiteboxTools for catchment delineation'
subtitle: '**Not for circulation or citation**'
author: |
  | R.D. (Dan) Moore
  | Department of Geography
  | The University of British Columbia
  | *email*: dan.moore@ubc.ca
date: '`r format(Sys.Date(), "%Y-%b-%d")`'
header-includes:
- \usepackage{lineno}
- \linenumbers
- \usepackage{setspace}\onehalfspacing
- \usepackage{url}
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    theme: cerulean
  bookdown::pdf_document2:
    number_sections: FALSE
  bookdown::word_document2:
    number_sections: FALSE
bibliography: catchment_delineation.bib
---

```{R, include = FALSE}
library(knitr)
library(here)
library(dplyr)
library(tidyr)
library(magrittr)
library(bookdown)
library(sf)
library(raster)
library(whitebox)
library(CSHShydRology)
library(viridis)
library(ggplot2)
```


# Introduction

A first step in many hydrologic investigations is to delineate the catchment boundary for a given point of interest (POI) on a stream. Catchment boundaries encompass the area within which any water reaching the surface, if allowed to flow over the surface without evaporating, would eventually drain through the stream past the POI. Catchment boundaries are conventionally defined by topographic divides, a.k.a. drainage divides or heights of land (note that in Britain the term watershed is used as a synonym for drainage divide).

Prior to the widespread availability of digital elevation models (DEMs) and software packages to perform digital terrain analysis, topographic maps at an appropriate scale were normally to delineate the catchment area. Field investigations were often useful to ascertain the direction of water drainage in low-relief terrain, where contours would be widely spaced and inferred flow paths subject to relatively high uncertainty.

Over the last three decades, the increasing availability of gridded DEMs and software to perform digital terrain analysis has facilitated a shift from manual delineation based on analogue contour maps to automated delineation based on DEMs. While routines incorporated in proprietary software packages by ESRI and other companies are in common usage, several free and open-source software (FOSS) packages also provide functions for catchment delineation; these include GRASS [@grassgis], SAGA GIS [@Conrad2015GMD], Tau-DEM [@taudem5] and WhiteboxTools [@whiteboxtools]. An advantage of using FOSS applications is that it promotes reproducibility by removing financial or other barriers to running a workflow. 

Reproducibility of analyses is enhanced by using a programming language such as R or Python to develop integrated workflow [@Moore2017Confluence]. The R language, in particular, is popular in the hydrological community [@Slater2019HESS]. The use of R and associated software such as RStudio and R Markdown facilitates the development of integrated workflows that encompass the full chain of operations, from data acquisition and wrangling to data analysis to report generation.

The objective of this document and exercise is to introduce the use of R and WhiteboxTools for catchment delineation. The exercise also introduces some of the objects and functions defined in the **raster** and **sf** packages as required in catchment delineation workflows.

The article illustrates the process using two examples. The workflows described in this article draw require the following packages to be installed: **dplyr**, **magrittr**, **here**, **bookdown**, **sf**, **raster**, **whitebox**, **CSHShydRology** and **viridis**.


# Setting up the workspace

This file should be in the root directory for a project associated with this workshop, within a sub-directory named *document* or similar name. The project root directory should also contain directories named *data* and *output*. The *data* directory should contain the digital elevation models for Upper Penticton Creek.

The following code chunk checks whether the *data* and *output* directories exist.

```{r}
# create path names for the directories
data_dir <- here::here("data")
out_dir <- here::here("output")
```

```{r}
# check the paths
data_dir
out_dir
```

Check that the directories exist.

```{r}
# data_dir
if (dir.exists(data_dir)) {
  sprintf(paste(data_dir, "exists"))
} else {
  sprintf(paste(data_dir, "does not exist"))
}
```

```{r}
# out_dir
if (dir.exists(out_dir)) {
  sprintf(paste(out_dir, "exists"))
} else {
  sprintf(paste(out_dir, "does not exist"))
}
```

Check that the Upper Penticton Creek DEMs exist. Their names are *gs_be240.tif* and *gs_be242.tif*. The first step is to create path names for the files.

```{r}
# create path names for the DEM files
fn_dem <- c("gs_be240.tif", "gs_be242.tif")
dem_paths <- file.path(data_dir, fn_dem)
dem_paths
```

Check whether the DEM files exist in the *data* directory.

```{r}
# loop over path names for the DEMs
for (i in seq_along(dem_paths)) {
  if (file.exists(dem_paths[i])) {
    print(paste(dem_paths[i], "exists"))
  } else {
    print(paste(dem_paths[i], "does not exist"))
  }
}
```

The other file that is required is one that contains the locations of the Water Survey of Canada gauging sites on the UPC study streams. A file containing this information in GeoJSON format (an open standard for storing spatial vector data); the file's name is *gs_weirs.GeoJSON*. 

The next code chunk checks that the data file is available in the *data* directory.

```{r}
fn_weirs <- file.path(data_dir, "gs_weirs.GeoJSON")
if (file.exists(fn_weirs)) {
  print(paste(fn_weirs, "exists"))
} else {
  print(paste(fn_weirs, "does not exist"))
}
```

# Example data sets

## Maunga Whau

The first example is based on a data set built into base R named `volcano`, which is 10-m-resolution DEM for Maunga Whau (Mt Eden) near Auckland, New Zealand Aotearoa. The data are stored as a matrix with 87 rows and 61 columns. 

The `ch_volcano_raster()` function in the **CSHShydRology** package converts the matrix into a *RasterLayer* object, with $x$ and $y$ coordinates that are consistent with the feature's easting and northing coordinates in UTM zone 60. 

The following code chunk creates the DEM and stores it in the *data* directory.

```{r}
# create raster DEM 
vol_dem <- ch_volcano_raster()

# file name for GeoTIFF file
fn_vol_dem <- file.path(data_dir, "vol_dem.tif")

# save the raster object if it does not already exist
if (!file.exists(fn_vol_dem)) {
  raster::writeRaster(vol_dem, fn_vol_dem)
} 
```


## Upper Penticton Creek

The second example is based on 1-m-resolution DEMs for the Upper Penticton Creek (UPC) experimental watersheds. The DEMs were based on Lidar imagery. One DEM covers the catchments areas for 240 and 241 Creeks, and another covers the catchment area for 242 Creek. The DEMs and the GeoJSON file containing the gauging station locations are available via a Zenodo repository [@Moore2021HPdatanote], but you can access them via Github.


# Introduction to Raster objects

In this exercise, we use the **raster** package for handling spatial raster data. However, a new package named **terra** has become available via CRAN, which has some advantages over **raster** in terms of processing speed and functionality. The following link leads to a comparison of the two packages (as of 2021-May-28):

* https://www.seascapemodels.org/rstats/2021/05/28/terra-raster-comparison.html

Now that the community is gaining experience with the new package and bugs and other issues become corrected, it is recommended that user consider shifting from **raster** to **terra**.


## Types of **raster** objects

There are three types of objects defined within the **raster** package: RasterLayer, RasterStack and RasterBrick.

### RasterLayer 

A RasterLayer contains the values and attributes for a single image. The values are stored as a matrix, and can be of various types, including numeric, character, factor and logical. 

The attributes of a RasterLayer include the numbers of rows and columns, the extent (minimum and maximum values of the x and y dimensions) and the coordinate reference system. Note that that matrix containing the values is structured differently from an object of class `matrix` in that values are assigned row-wise rather than column-wise.

The RasterLayer object can point to a file on disk that holds the values of the raster cells (for large objects), or hold these values in memory (for smaller objects). A RasterLayer can also contain just the attributes and not have any associated values.

RasterLayer objects are S4 objects, and are structured around a series of nested levels of "slots," which contain the data and information about the object.

### RasterStack and RasterBrick

RasterStack objects contain a set of RasterLayer objects that have the same extent and resolution. They can be used to store multiple data layers (e.g., different spectral bands for satellite imagery, or time series of images for a given spectral band, or different climatic variables).

Organizing RasterLayer objects in a RasterStack can be practical when dealing with multiple layers -- for example, to summarize their values (see `raster::calc()`) or in spatial modelling (see `raster::predict()`).

Like a RasterStack, RasterBrick objects can contain multiple layers of raster data, but they are more tightly related. An important difference is that objects of class RasterBrick can refer to only a single (multi-layer) data file, whereas each layer in a RasterStack can refer to a separate file (or another band in a multi-band file).

As a result of this difference, operations on a RasterBrick should process more quickly than on a RasterStack (irrespective of whether values are on disk or in memory). However, a `RasterStack` is more flexible as a single object can refer to layers that have values stored on disk (in multiple files) as well as in memory.

## Attributes associated with a Raster\* object

Some of the main attributes are summarized below. 

```{r, echo = FALSE}
table_cap <- "Summary of some of the main raster attributes stored in slots"
slot_name <- c("title", "file", "data", "extent", "ncols", "nrows", "crs")
data_type <- c(
  "Character",
  "Object of class '.RasterFile'",
  "Object of class '.SingleLayerData' or  '.MultipleLayerData'",
  "Object of Extent-class (analogous to a bounding box for sf objects)",
  "Integer",
  "Integer",
  "Object of class 'CRS', i.e. the coordinate reference system"
)
rs_table <- data.frame(slot_name, data_type)
names(rs_table) <- c("Slot name", "Data type")
knitr::kable(rs_table, caption = table_cap)
```


### Coordinate reference system

Several distinct standards are used to define coordinate reference systems, including PROJ.4, WKT (well-known text), EPSG (European Petroleum Specialty Group) and, most recently, PROJ.6. 

The `crs` attribute of a Raster object contains the coordinate reference system, expressed as a proj4 string and WKT2. 

The coordinate reference system can  be extracted directly from a Raster object in one of two ways:

```{r}
# use crs() extractor function
crs(vol_dem)
```

```{r}
# extract crs slot
vol_dem@crs
```

As can be seen, the `crs` for a raster object is provided in both proj4string (PROJ.4) and WKT2 formats. These can be extracted as follows:

```{r}
proj4string(vol_dem)
```

```{r}
wkt(vol_dem)
```

Note that the proj4string standard is now deprecated, but the newer PROJ.6 standard does not yet appear to be implemented in the **raster** package.


### Extent

The `extent` attribute defines the boundaries of the raster image. It can be extracted directly from the Raster\* object.

```{r}
vol_dem_ext <- extent(vol_dem)
```

The `extent` is an S4 object with four slots. The next code chunk displays its structure.

```{r}
str(vol_dem_ext)
```

The code chunk below extracts the extent into separate variables for later use.

```{r}
xmin <- vol_dem_ext@xmin
xmax <- vol_dem_ext@xmax
ymin <- vol_dem_ext@ymin
ymax <- vol_dem_ext@ymax
```

### Numbers of columns, rows and cells

The numbers of columns and rows are attributes in the raster, and can be accessed, for example, as `vol_dem@ncols` and `vol_dem@nrows`. They can also be extracted directly from the `RasterLayer` using the following extractor functions.

```{r}
nrow(vol_dem)
ncol(vol_dem)
```

The total number of cells can be extracted using the `ncell()` function

```{r}
ncell(vol_dem)
```


### Resolution

The resolution for the x and y coordinates can be extracted using the `res()` function. As seen below, the resolution in both directions is 10 m.

```{r}
res(vol_dem)
```

### `file`

The `file` attribute is an S4 object that has a number of slots. The following code generates a complete list of the slots for the `file` attribute.

```{r}
vol_dem@file
```

For example, the slot `name` within the `file` attribute contains the path of the file that contains the raster image.

```{r}
vol_dem@file@name
```

In this case, the object is sufficiently small that it is stored in memory.


## Visualizing raster data

Raster objects can be visualized using both the `plot()` method or `ggplot()`. The `plot()` method renders more quickly, especially for large rasters, and is used in most of the examples in this installment. 

As explained in the documentation for the `raster::plot()` method, most of the code for plotting a single Raster object is based on the `image.plot()` function in the **fields** package.

The main argument of the `plot()` method is the name of a Raster\* object. As seen in the plot below, the raster is filled in with values row-wise, starting in the top left corner. This contrasts with matrices, which are filled column-wise.

```{r, quick-map-dem, fig.cap = fig_cap}
fig_cap <- "Simple raster plot to check the volcano DEM"
plot(vol_dem)
```

We can modify the plot in various ways by providing additional arguments.

```{r, mod-vol-plot, warning = FALSE, message = FALSE, fig.cap = fig_cap}
fig_cap <- "Raster plot of volcano DEM with options to customize it"

# change tick length and tick label position
par(tcl = -0.2, mgp = c(2, 0.5, 0))
plot(vol_dem, 
  axes = FALSE,
  box = FALSE,
  legend.args = list(
    text = "Elev. (m)",
    line = 1
  ),
  legend.mar = 10
)
axis(1, pos = ymin, at = seq(xmin, xmax, 100))
axis(2, pos = xmin, at = seq(0.9*ymin, 1.1*ymax, 100))
rect(xmin, ymin, xmax, ymax)
mtext(side = 1, "UTM Easting (m)", line = 2)
mtext(side = 2, "UTM Northing (m)", line = -3)
```

The default colour palette is a reversed version of `terrain.colors`. Different palettes, can be used, as in the following example.

```{r, raster-pal-options, fig.cap = fig_cap, warning = FALSE, message = FALSE}
fig_cap <- "Illustration of different palettes for plotting raster images"

# vector containing color-palette function calls as character strings
dem_pal_formula <- c(
  "heat.colors(255)",
  "topo.colors(255)",
  "grey(100:0/100)",
  "viridis(255)"
)

# create a list containing the palettes
dem_pal <- list()
for (i in seq_along(dem_pal_formula)) {
  dem_pal[[i]] <- eval(parse(text = dem_pal_formula[i]))
}

# store existing parameter settings
opar <- par()
par(mfrow = c(2, 2), tcl = -0.2, mgp = c(2, 0.5, 0), mar = c(2, 2, 2, 4))
for (i in 1:4) {
  plot(vol_dem, 
    main = dem_pal_formula[i],
    col = dem_pal[[i]],
    axes = FALSE,
    box = FALSE,
    legend.args = list(
      text = "Elev. (m)",
      line = 1
    ),
   legend.mar = 6
  )
}

# restore parameter setting to original values
par(opar)
```

Contour maps can also be generated from Raster objects, as shown in the next code chunk.

```{r, volcano-contour, fig.cap = fig_cap}
fig_cap <- "Contour map of Maunga Whau. Contour interval = 10 m"
par(tcl = -0.2, mgp = c(2, 0.5, 0))
contour(vol_dem,
  levels = seq(90, 200, 10),
  col = "blue",
  asp = 1,
  axes = TRUE,
  xlab = "UTM Easting (m)",
  ylab = "UTM Northing (m)"
)
```



# Catchment delineation -- processing steps

Catchment delineation involves the following steps:

1. Remove sinks from the DEM
2. Determine flow directions for each cell based on steepest descent
3. Use the flow directions to determine the upslope contributing area for each cell. The result is often called a "flow accumulation" grid.
4. "Snap" the pour points to the cell within a specified window that has the highest flow accumulation, which is assumed to lie on the channel network.
5. Use the flow direction grid to identify all cells for which flow paths originating at that cell would flow through the pour point. These cells represent a raster version of the catchment area.
6. Convert the raster catchment area to a polygon.

In addition to the steps listed above, it is common to generate a channel network as well as the catchment boundaries. This step will be included in the examples presented below.


# Catchment delineation within R using **whitebox** functions

## Overview

This section describes the steps involved in catchment delineation based on a gridded DEM, and their implementation using functions from the **whitebox** package.

Information about WhiteboxTools and its functions can be found via:

* https://www.whiteboxgeo.com/manual/wbt_book/intro.html

In particular, the manual provides descriptions of the algorithms used in the functions.

More information on the **whitebox** package for R and its functions can be found via:

* https://giswqs.github.io/whiteboxR/index.html

A key difference between applying functions in R and WhiteboxTools functions is that the inputs and outputs for R functions are R objects. For example, the `focal()` functions takes a raster object as input (along with additional arguments) and returns a raster object. In contrast, input data and output arguments for WhiteboxTools functions are the names of files that contain the data.

We use the Maunga Whau DEM to illustrate the workflow.


## Sink removal

### Definition, origin and consequences of sinks in a DEM

A sink is a local topographic depression. When tracing flow paths through a DEM -- usually down the path of steepest descent -- any flow path that enters a sink will terminate at the low point of the sink. Sinks within DEMs can represent real features, such as prairie potholes or volcanic cones, or they may be artefacts of the DEM-generation process. 

For hydrological simulation, it can be critical to account for the presence of sinks, as the areas draining into them are typically not connected to the channel network until they are filled to the point of spilling the low point in their local drainage divide. However, for purposes of determining gross drainage areas, they should be removed as a first processing step.


### Approaches for removing sinks

Two main approaches can be used to remove sinks. The first is to fill the sinks until they overflow. It is common to impose a slope on the filled areas so water would flow across them to generate continuous flow paths through the DEM. The second approach involves lowering cell elevations in order to breach the sink. The latter approach is often preferred because it minimizes the amount of change to the DEM.

**whitebox** supports the first approach via following functions:

1. `wbt_fill_depressions()`
2. `wbt_fill_depressions_planchon_and_darboux()`
3. `wbt_fill_depressions_wang_and_liu()`
4. `wbt_fill_single_cell_pits()`

**whitebox** supports the second approach via the following functions:

5. `wbt_breach_depressions()`
6. `wbt_breach_depressions_least_cost()`
7. `wbt_breach_single_cell_pits()`

Note that function 4 can be useful to apply before functions 5 or 6 if the DEM contains isolated deep sinks, to avoid having a deep "trench" cut into the DEM.


### Application

As can be seen in Figures \@ref(fig:volcano-contour) and \@ref(fig:volcano-raster), especially in the raster plot, the volcanic cone is a local topographic depression, or sink. Therefore, this DEM provides a good example for illustrating the different approaches to sink removal. 

We first remove sinks by breaching. The first step is to create file names for the output DEMs.

```{r}
fn_input_dem <- file.path(data_dir, "vol_dem.tif")
fn_single_cell_filled_dem <- file.path(out_dir, "vol_dem_filled.tif")
fn_dem_no_sinks <- file.path(out_dir, "vol_dem_no_sinks.tif")
```

Now fill single-cell pits. Note that the arguments `dem` and `output` are file names, not R objects.

```{r}
wbt_fill_single_cell_pits(
  dem = fn_input_dem,
  output = fn_single_cell_filled_dem
)
```

Finally, remove the sinks using the least-cost breaching algorithm. The argument `dist` is the maximum search distance for breach paths in cells. We set it somewhat arbitrarily to five times the DEM resolution.

```{r}
wbt_breach_depressions_least_cost(
  dem = fn_single_cell_filled_dem,
  output = fn_dem_no_sinks,
  dist = 5*res(vol_dem)[1]
)
```

Now look at the result, first as a raster image of the DEM following breaching of sinks. In the raster plot below, you can see the line of cells that have been incised into the DEM to link the low point in the crater with a flow path that leads to the edge of the DEM

```{r, volcano-breachsinks, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster plot of the Maunga Whau DEM following sink removal by breaching.",
  "Grid resolution is 10 m"
)
# read in DEM from file
dem_no_sinks <- raster::raster(fn_dem_no_sinks)

# raster plot
par(tcl = -0.2, mgp = c(2, 0.5, 0))
plot(dem_no_sinks,
  asp = 1,
  box = FALSE,
  axes = FALSE,
  legend.args = list(
    text = "Elev. (m)",
    line = 1
  ),
  legend.mar = 10
)
```

Now look at the DEM of difference between the sink-removed and original DEMs. The incised series of cells is more obvious.

```{r, volcano-diff-breachsinks, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster plot of the Maunga Whau DEM following sink removal by breaching,",
  "along with contour lines derived from the original DEM.",
  "Grid resolution is 10 m"
)
# dem of difference
dod <- dem_no_sinks - vol_dem

# raster plot
par(tcl = -0.2, mgp = c(2, 0.5, 0))
plot(dod,
  col = rev(viridis(255)),
  asp = 1,
  box = FALSE,
  axes = FALSE,
  legend.args = list(
    text = expression(Delta*z ~  "(m)"),
    line = 1
  ),
  legend.mar = 10
)
contour(vol_dem,
  add = TRUE,
  col = "grey",
  levels = seq(90, 200, 10)
)
```

Now remove sinks by filling using the Planchon-Darboux algorithm.

```{r}
# file name for output
fn_dem_filled <- here::here("output", "vol_dem_filled.tif")

# run the function
wbt_fill_depressions_planchon_and_darboux(
  dem = fn_input_dem,
  output = fn_dem_filled
)
```

Now look at the result, first as a raster image of the DEM following filling of sinks.

```{r, volcano-fill-sinks, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster and contour plots of the Maunga Whau DEM following sink removal",
  "by filling.",
  "Grid resolution is 10 m"
)
# read in DEM from file
dem_filled <- raster::raster(fn_dem_filled)

# raster plot
par(tcl = -0.2, mgp = c(2, 0.5, 0))
plot(dem_filled,
  asp = 1,
  box = FALSE,
  axes = FALSE,
  legend.args = list(
    text = "Elev. (m)",
    line = 1
  ),
  legend.mar = 10
)
contour(dem_filled,
  add = TRUE,
  col = "blue",
  levels = seq(90, 200, 10)
)
```

Now look at the DEM of difference between the sink-removed and original DEMs.

```{r, volcano-diff-fillsinks, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster plot of the DEM of difference between Maunga Whau DEM following sink",
  "removal by filling and the original DEM, along with contours based on the",
  "original DEM. Grid resolution is 10 m"
)

# dem of difference
dod <- dem_filled - vol_dem

# raster plot
par(tcl = -0.2, mgp = c(2, 0.5, 0))
plot(dod,
  col = rev(viridis(255)),
  asp = 1,
  box = FALSE,
  axes = FALSE,
  legend.args = list(
    text = expression(Delta*z ~  "(m)"),
    line = 1
  ),
  legend.mar = 10
)
contour(vol_dem,
  add = TRUE,
  col = "blue",
  levels = seq(90, 200, 10)
)
```

Figures \@ref(fig:volcano-diff-fillsinks) and \@ref(fig:volcano-diff-breachsinks) nicely illustrate the difference in operation and result between the two approaches. From this point on, we will continue the processing using the DEM resulting from the sink-breaching algorithm.


## Flow directions

For catchment delineation, flow directions are determined using the D8 (deterministic-8) method, which returns the direction of steepest descent from each cell to its neighbours. This step is performed by the `wbt_d8_pointer()` function.

```{r}
# create file name for flow direction grid
fn_flow_dir <- file.path(out_dir,  "vol_flow_dir.tif")

# apply 
wbt_d8_pointer(
  dem = fn_dem_no_sinks,
  output = fn_flow_dir
)
```

The flow directions are coded as $2^i$, where $i = 0, 1, 2, ..., 7$, $i = 0$ indicates flow to the east, and $i$ increases clockwise. 

```{r, volcano-flowdir, fig.cap = fig_cap}
fig_cap <- paste(
  "Flow direction grid following sink removal by breaching.",
  "Grid resolution is 10 m"
)
# look at output - first read output into a Raster object
flow_dir <- raster::raster(fn_flow_dir) 

# raster plot
plot(flow_dir)
```


## Flow accumulation

The `wbt_d8_flow_accumulation()` function can take either a DEM (after removing sinks) or a flow direction grid as input. If a DEM is specified as input, the function will first determine flow directions. If a flow direction grid is used as input, the argument `pntr = TRUE` must be included. The default output is the number of upslope cells that ultimately drain through each grid cell. This can be changed to 'catchment area' or 'specific contributing area' via the `out_type` argument. See WhiteboxTools documentation for details.

```{r}
# create file name for flow accumulation grid
fn_flow_acc <- file.path(out_dir, "vol_flow_acc.tif")

# apply function
wbt_d8_flow_accumulation(
  input = fn_flow_dir,
  output = fn_flow_acc,
  pntr = TRUE
)
```

```{r, volcano-flowacc, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster plot of the Maunga Whau flow accumulation grid.",
  "Values shown are the number of contributing cells for each grid cell.",
  "Grid resolution is 10 m"
)
# look at result
fa <- raster(fn_flow_acc)
plot(fa,
  asp = 1,
  box = FALSE,
  axes = FALSE,
  legend.args = list(
    text = "Number of cells"
  ),
  legend.mar = 10
)
```

```{r, volcano-flowacc-log10, fig.cap = fig_cap}
fig_cap <- paste(
  "Raster plot of the Maunga Whau flow accumulation grid.",
  "Values shown are the base-10 logarithms of the number of contributing",
  "cells for each grid cell.",
  "Grid resolution is 10 m"
)
# log10 transformation
plot(log10(fa),
  axes = FALSE,
  box = FALSE,
  legend.args = list(
    text = expression(log[10]*(n[cells]))
  ),
  legend.mar = 10
)      
```


## Snap pour points

Prior to determining the catchment areas for the points of interest along the stream, it is important to "snap" them to a grid cell along the gridded representation of the stream network. In practical terms, this operation involves searching within a defined window around the actual POI coordinates for the grid cell with the highest flow accumulation value.
 
The points of interest along the stream, a.k.a, "pour points," must be in a spatial vector data file. Here, we use ESRI shapefile format. The first step, then, is to generate a shapefile containing the pour points. The following code chunk creates two test pour points and saves them to a file.

```{r}
# outlet points for catchment delineation - first as data frame
test_outlet <- data.frame(x = c(300570, 300644),
                          y = c(5916757, 5916557)) %>%
  mutate(test_label = c("test_1", "test_2"))
test_outlet
```

```{r}
# create sf object from the data frame; set crs to UTM zone 60 using EPSG
outlet_sf <- test_outlet %>% 
  st_as_sf(coords = c("x", "y")) %>%
  st_set_crs("EPSG:32760")
outlet_sf
```

```{r}
# create file name and save pour point file
fn_pp <- file.path(out_dir, "volcano_poi.shp")
write_sf(outlet_sf, fn_pp, delete_dsn = TRUE)
```

Next apply `wbt_snap_pour_points()`. There are four main arguments: 

* `pour_pts`, the name of the shape file that contains the pour point locations; 
* `flow_accum`, the name of the file containing the flow accumulation grid; 
* `output`, the name of the file in which to store the snapped pour points; and 
* `snap_dist`, which limits how far the algorithm will look for the cell with maximum flow accumulation. We set it here, somewhat arbitrarily, to 50 m. An appropriate value for this argument depends on the horizontal accuracies of both the DEM and the pour point locations.


```{r}
# specify name of output 
fn_pp_snap <- file.path(out_dir, "vol_pp_snap.shp")

# apply function
wbt_snap_pour_points(
  pour_pts = fn_pp,
  flow_accum = fn_flow_acc,
  output = fn_pp_snap,
  snap_dist = 50
)
```


## Delineate catchment

There are two functions required for the final step. The first, `wbt_watershed()`, generates a raster image of the catchment; the second converts the raster image to vector polygons.

The next code chunk performs the first step.

```{r}
# name of file to store catchments as a raster image
fn_catchment_ras <- file.path(out_dir, "vol_catchments.tiff")

wbt_watershed(
  d8_pntr = fn_flow_dir,
  pour_pts = fn_pp_snap,
  output = fn_catchment_ras
)
```

Now generate a map. This version shows the points of interest with their original coordinates, not the snapped points.

```{r, volcano-catch-ras, fig.cap = fig_cap}
fig_cap <- paste(
  "Delineated catchments in raster format.",
  "Grid resolution is 10 m"
)
# look at result
vol_catch_ras <- raster::raster(fn_catchment_ras)

plot(vol_catch_ras, 
  col = c("pink", "lightblue")
)
contour(vol_dem, 
  add = TRUE
)
plot(outlet_sf, 
  add = TRUE,
  pch = 21:22,
  bg = c("red", "blue"),
  col = "black"
)
```


The next code chunk converts the raster image to vector format.

```{r}
fn_catchment_vec <- file.path(out_dir, "vol_catchments.shp")
wbt_raster_to_vector_polygons(
  input = fn_catchment_ras,
  output = fn_catchment_vec
)
```

Now generate a map to check. Again, the points of interest are shown at their original coordinates.

```{r, volcano-catch-vec, fig.cap = fig_cap}
fig_cap <- paste(
  "Delineated catchments as vector polygons.",
  "Grid resolution is 10 m"
)
# look at result - first read in file
vol_catch_vec <- read_sf(fn_catchment_vec)

# extract the geometry for plotting
vol_catch_geo <- st_geometry(vol_catch_vec) 

# plot polygons, use bbox for original dem to define plot extent
plot(vol_catch_geo,
  extent = st_bbox(vol_dem),
  asp = 1,
  col = c("pink", "lightblue") 
)  
contour(vol_dem,
  add = TRUE
)
plot(outlet_sf, 
  add = TRUE,
  pch = 21:22,
  bg = c("red", "blue"),
  col = "black"
)
```


## Delineate the channel network

Similarly to the delineation of catchment areas, delineating channel networks involves two steps: the first generates a raster image of the channel network; the second converts the raster image to vector format.

In the first step, the function `wbt_extract_streams()` has three main arguments: `flow_accum` is the file name for a flow accumulation grid, `output` is the file name for the resulting raster image, and `threshold` is the threshold flow accumulation for channel initiation. Here, the threshold has been set somewhat arbitrarily at 20. This value can be adjusted based on visual examination of the resulting network.

```{r}
fn_channel_ras <- file.path(out_dir, "vol_channels.tif")
wbt_extract_streams(
  flow_accum = fn_flow_acc, 
  output = fn_channel_ras, 
  threshold = 20
)
```

The next step converts the raster image to vector format. There are three main inputs: `streams`, the name of the file containing the raster image, `d8_pntr`, the name of the file containing the flow direction grid, and `output`, the name of the file in which the result should be saved.

```{r}
fn_channel_vec <- file.path(out_dir, "vol_channels.shp")
wbt_raster_streams_to_vector(
  streams = fn_channel_ras,
  d8_pntr = fn_flow_dir,
  output = fn_channel_vec
)
```


## Generate a map using base graphics

The code chunk below generates a map of the delineated catchments and channel network, along with the snapped pour points and the elevation contours.

```{r, volcano-map, fig.cap = fig_cap, warning = FALSE, message = FALSE}
fig_cap <- paste(
  "Map of Maunga Whau showing elevation contours, snapped points of interest,",
  "delineated catchments and the channel network."
)
# read in catchment polygons and cast to lines
catchments <- st_read(fn_catchment_vec)
catchment_outlines <- st_cast(catchments, 'MULTILINESTRING')

# read in channels
channels <- st_read(fn_channel_vec)

# read in snapped pour points
pp_snap <- st_read(fn_pp_snap)

# plot
contour(vol_dem, asp = 1, col = "grey")
plot(pp_snap, 
  pch = 16,
  pal = c("brown", "darkgreen"),
  add = TRUE
)
plot(st_geometry(channels),
  col = "blue",
  add = TRUE
)
plot(st_geometry(catchment_outlines), 
  fill = NA,
  col = c("brown", "darkgreen"),
  add = TRUE
)
```


# Introduction to **sf** objects

In the workflow applied above, three spatial vector objects were created:

1. spatial point data (pour points)
2. spatial line data (channel network)
3. spatial polygons (catchment polygons)

Before the introduction of the **sf** package a few years ago, the main R package for handling spatial vector data was the **sp** package. As is the case with the **raster** package, **sp** objects are S4 objects. In contrast, **sf** objects are S3 objects and are, in fact, an extension of a data frame. The main distinguishing feature of an **sf** object is that one of the columns is a list-column that contains the geometry for each feature.

For example, look at `outlet_sf`:

```{r}
head(outlet_sf)
```

As can be seen, there are two rows, one for each point, and two columns. The first column, `test_label`, contains the names of the points, and is a character vector. The second, named `geometry`, is a list-column that contains, no surprise, the geometry information for each object. In this case, both objects are POINT features, and the value in brackets are the x-y coordinates.

Now look at `channels`.

```{r}
head(channels)
```
In this case, each row represents one stream segment. The geometry of each stream segment is a LINESTRING.

As seen below, the `catchments` object contains two rows, one for each catchment. The catchment area for each is a MULTIPOLYGON.

```{r}
head(catchments)
```

Like Raster objects, **sf** objects also have a coordinate reference system, which can be extracted using the `st_crs()` function.

```{r}
st_crs(catchments)
```

As seen in the next three code chunks, the coordinate reference system can be extracted based on the EPSG, WKT and PROJ.4 standards, as needed.

```{r}
st_crs(catchments)$epsg
```

```{r}
st_crs(catchments)$wkt
```


```{r}
st_crs(catchments)$proj4string
```


The area of a polygon can be extracted using the `st_area()` function.

```{r}
ca <- st_area(catchments)
ca
```

The result has class "units", which means it is a numeric vector that has the units of measurement as an attributed. The components can be extracted as follows.

```{r}
ca_vals <- as.numeric(ca)
ca_vals
```

The units can be extracted using the `units()` function. The result is a list with two components: `numerator` and `denominator`.

```{r}
ca_units <- units(ca)
str(ca_units)
```

For more information on the **sf** package and its application in hydrologic analyses, see the CSHS webinar on the topic:

* https://cshs.cwra.org/en/cshs-hydrology-spatialprocessing/


# Running **whitebox** functions using **CSHShydRology** functions

## Overview

The **CSHShydRology** package has a set of functions that act as wrappers for incorporating the **whitebox** functions in R scripts. The functions all begin with `ch_wbt_` as a prefix.

There is a helper function, `ch_wbt_filenames()`, which generates a set of default file names to be used as input and output to the **whitebox** functions. 

One feature is that each **CHSHhydRology** function returns an R object, which facilitates checking the output of each step. Each function also includes error traps, such as checking that objects have the same coordinate reference system.

Whereas **whitebox** contains seven separate functions for removing sinks, the **CSHShydRology** package contains a single function that allows you to choose the algorithm as an argument. This approach facilitates comparison of the effects of the different algorithms in specific situations.

The functions that generate the channel network and the catchment polygons combine the separate steps of generating a raster image and then converting it to a spatial vector object.

There are also two plotting functions for checking the output, which use `ggplot()` to generate maps: `ch_checkchannels()`, which generates a plot of the contours and the channel network, and `ch_checkcatchments()`, which generates a map showing contours, the channel network, the pour points and the catchments. 


## Example workflow using the UPC data sets and individual `ch_wbt_` functions

The code chunks below provide an example workflow that uses the `ch_wbt_` functions sequentially. We first read in the Lidar-derived DEM that covers the catchments for 240 and 241 Creeks, which is stored in the "output" folder for the project. The DEM has a resolution of 1 m in both x and y directions. The coordinate reference system is UTM Zone 11.

```{r}
fn_dem_240_1m <- file.path(data_dir, "gs_be240.tif")
dem_240_1m <- raster::raster(fn_dem_240_1m)
```

To reduce computing time, we resample the DEM to a 10-m resolution. The first step is to create an empty RasterLayer object to serve as a template.

```{r}
# first create a raster template with desired resolution
dem_ext <- extent(dem_240_1m)
dem_ras <- raster::raster(ext = dem_ext, crs = crs(dem_240_1m), res = 10)
```

The next step is to apply the `resample()` function from the **raster** package.

```{r}
# now resample the original DEM to the template
dem_240 <- raster::resample(dem_240_1m, dem_ras)
```

```{r}
# check characteristics of resampled DEM
extent(dem_240)
crs(dem_240)
res(dem_240)
```

Access the locations of the gauging stations; these will be the points of interest for the catchment delineation.

```{r}
# local file name for weir file
fn_weirs <- file.path(data_dir, "gs_weirs.GeoJSON")
weirs <- st_read(fn_weirs)
```

```{r}
# display weir locations
weirs
```

There are three weirs, but the DEM only covers the catchment areas for two. The next code chunk filters the weirs to include only the ones covered by the DEM. A convenient feature of **sf** objects is that, because they are extended data frames, one can process them using functions in **dplyr** and other packages.

```{r}
# filter to exclude 242 Creek weir as it is not in the DEM extent
two_weirs <- weirs %>%
  dplyr::filter(wsc_names %in% c("240", "241"))
two_weirs
```

Save the weir locations as an ESRI shapefile. Check to see whether the file already exists, and delete before writing if so, to avoid throwing an error.

```{r}
fn_pp <- here::here("output", "two_weirs.shp")
if (!file.exists(fn_pp)) {
  st_write(two_weirs, dsn = fn_pp)
} else {
  st_write(two_weirs, dsn = fn_pp, delete_dsn = TRUE)
}
```

Plot the DEM with weir locations as a visual check.

```{r, dem-240-check, message = FALSE, warning = FALSE, fig.cap = fig_cap}
fig_cap <- paste(
  "Map to check the resampled DEM for 240 and 241 Creeks.",
  "The gauging station locations are plotted as black filled symbols"
)

plot(dem_240,
  asp = 1,
  xlab = "UTM Easting (m)",
  ylab = "UTM Northing (m)",
  legend.args = list(
    text = "Elev. (m)",
    line = 1
  ),
  legend.mar = 10
)
plot(two_weirs, 
  add = TRUE,
  pch = 15:16,
  col = "black"
)
```

Generate default file names to simplify the function calls. The output of `ch_wbt_filenames()` is a list. 

```{r}
# create working directory to store files created by whitebox functions
upc_wd <- file.path(out_dir, "upc_240_241")
ch_create_wd(upc_wd)

# generate default file names
fn <- ch_wbt_filenames(wd = upc_wd)
```

Extract the DEM resolution for use in later function calls.

```{r}
# extract the dem resolution
dx <- res(dem_240)[1]
dx
```

Remove sinks using the breach algorithm. `fn_dem_240` contains the name of the file containing the original DEM, `fn$dem_ns` contains the default file name for the DEM with sinks removed, and `fn$dem_fsc` contains the default file name for the DEM generated by filling single-cell pits.

We first need to save the resampled DEM to a file so it can be read by the WhiteboxTools functions.

```{r}
# save resampled DEM to a file
fn_dem_resamp <- file.path(out_dir, "dem_resamp.tif")

# check whether file exists
if (!file.exists(fn_dem_resamp)) {
  writeRaster(dem_240, fn_dem_resamp)
}

# remove sinks using the breach algorithm
dem_ns <- ch_wbt_removesinks(
  in_dem = fn_dem_resamp, 
  out_dem = fn$dem_ns, 
  method = "breach",
  dist = 10*dx,
  fn_dem_fsc = fn$dem_fsc
)
```

Determine the flow accumulation and flow direction grids. Note that, unlike the `wbt_` functions, the `ch_wbt_` functions return an object that can be plotted or examined.

```{r}
# flow accumulation
flow_acc <- ch_wbt_flow_accumulation(
  fn_dem = fn$dem_ns, 
  fn_flowacc = fn$flowacc
)

# check plot
plot(flow_acc)
```


```{r}
# flow direction
flow_dir <- ch_wbt_flow_direction(
  fn_dem = fn$dem_ns, 
  fn_flowdir = fn$flowdir
)

# check plot
plot(flow_dir)
```

Delineate the channel network. 

```{r}
# channel network
channels_sf <- ch_wbt_channels(
  fn_flowacc = fn$flowacc, 
  fn_flowdir = fn$flowdir,
  fn_channel_ras = fn$channel_ras, 
  fn_channel_vec = fn$channel_vec,
  threshold = 300
)
```

Generate a plot to check using `ch_checkchannels()`.

```{r, channel-check, fig.cap = fig_cap}
fig_cap <- "Map to check channel network generated from the DEM"

# check plot
ch_checkchannels(
  dem = dem_ns, 
  channels = channels_sf, 
  outlet = two_weirs,
  contour_colour = "grey",
  channel_colour = "lightblue",
  pp_colour = "lightblue"
) 
```

Now snap the pour points to the raster channel network, using five times the DEM resolution to define the search window.

```{r}
# apply function
pour_points_sf <- ch_wbt_pourpoints(
  pp_sf = two_weirs, 
  fn_flowacc = fn$flowacc, 
  fn_pp = fn$pp, 
  fn_pp_snap = fn$pp_snap, 
  snap_dist = 5*dx
)

# check output
pour_points_sf
```


```{r}
# catchment delineation
catchments_sf <- ch_wbt_catchment(
  fn_pp_snap = fn$pp_snap, 
  fn_flowdir = fn$flowdir, 
  fn_catchment_ras = fn$catchment_ras, 
  fn_catchment_vec = fn$catchment_vec
)
```


```{r, check-catchment, fig.cap = fig_cap}
fig_cap <- "Map to visually check delineated catchment polygons"
# check plot
ch_checkcatchment(
  dem = dem_ns, 
  catchment = catchments_sf, 
  outlet = pour_points_sf, 
  channel_vec = channels_sf, 
  bbox_type = "catchment",
  channel_colour = "lightblue",
  pp_colour = c("lightblue", "pink"),
  cb_colour = c("blue", "red"),
  contour_colour = "darkgrey",
  na_location = "bl",
  plot_scale = FALSE
)
```


## Using the one-step function

As an alternative to running the sequence of functions illustrated in the preceding sections, the `ch_wbt_catchment_onestep()` function provides a shortcut. An example is provided below. The function returns the catchment polygons as an **sf** object and, by default, generates a map using `ggplot()`. To suppress the map, include `check_catchment = FALSE` as an argument.

```{r, onestep-example, fig.cap = fig_cap}
fig_cap <- "Map to check output from the one-step function"
# create working directory for wbt output files
wd_onestep <- file.path(out_dir, "upc_onestep")
ch_create_wd(wd_onestep)

upc_catchments <- ch_wbt_catchment_onestep(
  wd = wd_onestep,
  in_dem = fn_dem_resamp,
  pp_sf = two_weirs, 
  sink_method = "fill", 
  threshold = 300, 
  snap_dist = 5*dx,
  channel_colour = "lightblue",
  na_location = "bl"
)
```


# Exercises

## Explore the effect of `snap_dist` for the 240 and 241 catchments

Re-run the workflow using the separate `ch_wbt` functions, with different values for the `snap_dist` parameter -- e.g., `dx`, `10*dx` and `20*dx`. 

When you run the workflow using `snap_dist = dx`, try running `ch_checkcatchment()` with and without the argument `bbox_type = "contour"`.

Use `st_area()` to extract the catchment areas for comparison among the options.


## Run the workflow for the 242 Creek catchment

Read in the the DEM for the 242 Creek catchment from the "data" folder. The file name is *gs_be242.tif*.

Re-run the workflow to generate the catchment polygon using (a) the original DEM with 1-m resolution, (b) a resampled DEM with 10-m resolution, and (c) a resampled DEM with 25-m resolution (i.e., similar to the resolution of the Canadian DEM product).

Use base graphics to generate a plot that includes the three catchment boundaries. A suggested approach follows:

1. Use `contour()` to plot the contours using grey lines.
2. Use `plot()` with `add = TRUE` to add the channel network based on the original 1-m-resolution DEM.
3. Use three calls of `plot()` with `add = TRUE` to add the catchment polygons. Specify a different colour for each. 

Use `st_area()` to extract the catchment areas for the different resolutions. Summarize them in a table. How much do they differ?

# References {-}

<div id="refs"></div>






